#!/usr/bin/env bash

# import.sh links the necessary claude helper files to the build directory
# for the target that we're trying to match. this will be run automatically
# as part of setting up the build directory.

# Parse arguments
BOOTSTRAP=false
ARG=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --bootstrap)
            BOOTSTRAP=true
            shift
            ;;
        *)
            ARG="$1"
            shift
            ;;
    esac
done

CLAUDE_DIR="$(pwd)/tools/claude-decomp-env"
CLAUDE_CONFIG="$(pwd)/.claude"

create_unique_dir() {
    mkdir -p nonmatchings

    local base_dir="nonmatchings/$1"
    local dir="$base_dir"
    local counter=2

    while [ -d "$dir" ]; do
        dir="$base_dir-$counter"
        ((counter++))
    done

    mkdir -p "$dir"
    echo "$dir"
}

# Check if argument is provided
if [ -z "$ARG" ]; then
    echo "Usage: $0 [--bootstrap] <function_name_or_path_or_scratch_id>"
    exit 1
fi

# Check if the argument is a decomp.me scratch ID (numeric or alphanumeric with 5+ chars)
# Scratch IDs are typically 5-6 alphanumeric characters
if [[ "$ARG" =~ ^[0-9]+$ ]] || [[ "$ARG" =~ ^[a-zA-Z0-9]+$ && ${#ARG} -ge 5 && ${#ARG} -le 10 ]]; then
    echo "Detected scratch ID: $ARG"

    # Check for invalid --bootstrap + scratch ID combination
    if [ "$BOOTSTRAP" = true ]; then
        echo "Error: --bootstrap cannot be used with a scratch ID"
        echo "Bootstrap mode requires a function name to generate code from m2c"
        exit 1
    fi

    echo "Fetching from decomp.me API..."

    # Read user agent from .decomp_dev_secret
    USER_AGENT=""
    if [ -f .decomp_dev_secret ]; then
        USER_AGENT=$(head -n 1 .decomp_dev_secret | tr -d '\n\r')
    fi

    # Fetch the scratch data from decomp.me API
    if [ -n "$USER_AGENT" ]; then
        SCRATCH_DATA=$(curl -s -H "User-Agent: $USER_AGENT" "https://decomp.me/api/scratch/$ARG")
    else
        SCRATCH_DATA=$(curl -s "https://decomp.me/api/scratch/$ARG")
    fi

    if [ $? -ne 0 ] || [ -z "$SCRATCH_DATA" ]; then
        echo "Error: Failed to fetch scratch data from decomp.me"
        exit 1
    fi

    # Check if we got an error response
    if echo "$SCRATCH_DATA" | grep -q '"error"'; then
        echo "Error: Scratch not found or API error"
        echo "$SCRATCH_DATA"
        exit 1
    fi

    # Extract diff_label and source_code from JSON response
    DIFF_LABEL=$(echo "$SCRATCH_DATA" | python3 -c "import sys, json; data = json.load(sys.stdin); print(data.get('diff_label', ''))" 2>/dev/null)
    SOURCE_CODE=$(echo "$SCRATCH_DATA" | python3 -c "import sys, json; data = json.load(sys.stdin); print(data.get('source_code', ''))" 2>/dev/null)

    if [ -z "$DIFF_LABEL" ] || [ -z "$SOURCE_CODE" ]; then
        echo "Error: Could not extract diff_label or source_code from API response"
        exit 1
    fi

    # Use diff_label as the function name for ASM lookup
    FUNC_NAME="$DIFF_LABEL"
    USE_SCRATCH_SOURCE=true
else
    # Regular function name or path handling
    FUNC_NAME="$ARG"
    USE_SCRATCH_SOURCE=false
fi

# Check if the argument is already a full path
if [[ "$FUNC_NAME" == *.s ]]; then
    # It's already a path
    ASM_PATH="$FUNC_NAME"
else
    # It's just a function name, search for it
    # Add .s extension if not present
    if [[ "$FUNC_NAME" != *.s ]]; then
        FUNC_NAME="${FUNC_NAME}.s"
    fi

    # Find the file in asm/nonmatchings or asm/matchings
    ASM_PATH=$(find asm/nonmatchings asm/matchings -name "$FUNC_NAME" -type f 2>/dev/null | head -1)

    if [ -z "$ASM_PATH" ]; then
        echo "Error: Could not find assembly file for function: $FUNC_NAME"
        exit 1
    fi

fi

# Setup working directory
# Use the function name (without .s extension) for directory naming
if [ "$USE_SCRATCH_SOURCE" = true ]; then
    # Strip .s extension if present from DIFF_LABEL for directory name
    DIR_NAME="${DIFF_LABEL%.s}"
else
    # Use original argument for directory name
    DIR_NAME="$ARG"
fi
created_dir=$(create_unique_dir "$DIR_NAME")

# Populate with base / target files
if [ "$USE_SCRATCH_SOURCE" = true ]; then
    # Write the source code from the scratch to base.c
    echo "#include \"common.h\"" > "$created_dir/base.c"
    echo "$SOURCE_CODE" >> "$created_dir/base.c"
    echo "Using source code from decomp.me scratch"
elif [ "$BOOTSTRAP" = true ]; then
    # Use m2c to generate initial C code from assembly
    echo "Generating initial C code using m2c..."
    if ! command -v m2c &> /dev/null; then
        echo "Warning: m2c command not found. Creating blank base.c file."
        echo "#include \"common.h\"" > "$created_dir/base.c"
        echo "" >> "$created_dir/base.c"
        echo "// file is blank because m2c is not installed" >> "$created_dir/base.c"
    else
        # Determine the C file path from the ASM path
        # asm/nonmatchings/10AD0/func_8000FED0_10AD0.s -> src/10AD0.c
        # asm/nonmatchings/levels/crazy_jungle_boss/func_800BB2B0_ABAE0.s -> src/levels/crazy_jungle_boss.c
        ASM_DIR=$(dirname "$ASM_PATH")
        # Remove the "asm/nonmatchings/" or "asm/matchings/" prefix
        RELATIVE_DIR=${ASM_DIR#asm/nonmatchings/}
        RELATIVE_DIR=${RELATIVE_DIR#asm/matchings/}
        C_FILE="src/${RELATIVE_DIR}.c"

        # Generate context file if the C file exists
        CONTEXT_ARG=""
        if [ -f "$C_FILE" ]; then
            echo "Generating m2c context from $C_FILE..."
            if python3 tools/m2ctx.py "$C_FILE" 2>/dev/null; then
                if [ -f "ctx.c" ]; then
                    CONTEXT_ARG="--context ctx.c"
                    echo "Context file generated successfully"
                else
                    echo "Warning: Context file generation completed but ctx.c not found"
                fi
            else
                echo "Warning: Failed to generate context file, continuing without context"
            fi
        else
            echo "Note: C file $C_FILE not found, generating without context"
        fi

        # Generate C code using m2c with optional context
        M2C_OUTPUT=$(m2c --target mips-gcc-c $CONTEXT_ARG "$ASM_PATH" 2>&1)
        M2C_EXIT_CODE=$?

        if [ $M2C_EXIT_CODE -ne 0 ]; then
            echo "Warning: m2c failed to generate C code. Creating blank base.c file."
            echo "$M2C_OUTPUT"
            echo "#include \"common.h\"" > "$created_dir/base.c"
            echo "" >> "$created_dir/base.c"
            echo "// file is blank because m2c failed to decompile function" >> "$created_dir/base.c"
        else
            # Write m2c output to base.c
            echo "#include \"common.h\"" > "$created_dir/base.c"
            echo "" >> "$created_dir/base.c"
            echo "// This is a decompilation attempt by the m2c tool." >> "$created_dir/base.c"
            echo "// Function/type definitions might be missing or incomplete." >> "$created_dir/base.c"
            echo "// The code will likely not compile without further modification." >> "$created_dir/base.c"
            echo "" >> "$created_dir/base.c"
            echo "$M2C_OUTPUT" >> "$created_dir/base.c"
            echo "Generated initial C code from assembly using m2c"
        fi
    fi
else
    # Use temp.c as before
    cp src/temp.c "$created_dir/base.c"
fi
cat "${CLAUDE_DIR}/prelude.inc" "${CLAUDE_DIR}/../../include/macro.inc" "$ASM_PATH" > "$created_dir/target.s"
mips-linux-gnu-as -EB -march=vr4300 -mtune=vr4300 -Iinclude -o "$created_dir/target.o" "$created_dir/target.s"

# Add claude decomp helpers
ln -sf "${CLAUDE_DIR}"/* "$created_dir/"
ln -sf "${CLAUDE_CONFIG}" "$created_dir/"

if command -v claude &> /dev/null; then
    cd "$created_dir"
    claude "decompile ${FUNC_NAME%.s}. use thinking"
else
    echo "Success! Please navigate to the created directory and start your decompilation work:"
    echo ""
    echo "  cd $created_dir"
    echo ""
fi
