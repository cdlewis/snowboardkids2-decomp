func_80048F0C_49B0C 4 100%
func_80034750_35350 14 87.781%
isPlayerInRangeAndPull 20 83.201%
func_8002BAEC_2C6EC 20 59.320%
func_800BB63C_B45CC 20 89.019%
func_800BB89C_B482C 20 95.013%
func_80007B58_8758 16 96.912%
func_80062918_63518 1 100.000%
func_8002B248_2BE48 12 80.744%
func_80054144_54D44 20 85.443%
func_8000AD88_B988 20 84.589%
func_800BB3A0_B2120 14 90.384
func_800BC768_AEB28 20 76.215%
func_800340F4_34CF4 20 66.226%
func_80020D18_21918 20 86.825%
func_80033458_34058 20 76.692%
func_800B7128_1E41D8 11 58.743%
func_80053434_54034 13 90.863%
func_8004119C_41D9C 20 96.476%
func_8005B730_5C330 9 50.277%
func_8005BCB8_5C8B8 20 86.772%
func_80003184_3D84 20 79.900%
func_800626C4_632C4 20 82.946%
func_8001C920_1D520 7 82.712%
func_8001E5EC_1F1EC 11 92.075%
func_8003A294_3AE94 20 76.299%
func_8001B020_1BC20 4 87.491%
func_8000595C_655C 9 87.743%
func_80032708_33308 16 71.862%
createRotationMatrixZYX 20 36.611%
createRotationMatrixXYZ 20 88.113%
func_8005B9E4_5C5E4 20 69.956%
func_8003D210_3DE10 20 97.670%
func_80026D34_27934 14 57.867%
func_800B8874_1E5924 8 84.743%
func_80028074_28C74 20 95.805%
func_800BA4B8_AA368 20 80.492%
func_80015254_15E54 20 70.040%
func_8002D140_2DD40 10 95.990%
func_800597C0_5A3C0 10 55.266%
func_8006DC40_6E840 20 68.080%
func_8001E104_1ED04 17 99.111%
func_800B956C_1E661C 11 45.753%
func_8001DF5C_1EB5C 20 72.575%
func_800262D4_26ED4 7 51.0%
func_800B0F14_A0DC4 3 0%
initializeCutsceneSystem 15 92.0%
func_8002E314_2EF14 10 88.288%
func_80002C70_3870 6 34.536%
func_800B9B90_A9A40 8 41.126%
func_800BB488_B4D88 6 47.1%
computeLookAtMatrix 18 58.2%
func_800BB2B0_B07A0 4 100%
func_8006D820_6E420 16 89.459%
func_8002DA54_2E654 9 73.567%
func_800B6CD8_1E3D88 17 92.542%
updateModelGeometry 3 0%
func_8003D560_3E160 7 65.082%
func_80034D58_35958 13 86.327%
func_8005E22C_5EE2C 21 95.773%
func_8000AA08_B608 11 90.803%
func_80033AE4_346E4 17 63.448%
func_8000BFD0_CBD0 16 30.986%
func_8005BF50_5CB50 16 89.359%
func_80060A3C_6163C 16 31.723%
func_8003AC58_3B858 16 63.751%
func_8002A7CC_2B3CC 6 59.548%
transformVector2 12 90.5%
transformVector3 16 93.837%
func_800643AC_64FAC 17 91.063%
func_800B0388_1DC528 12 80.7%
func_800B6890_A6740 4 59.965%
func_8002A4AC_2B0AC (14 attempts, 84.175%)
func_8001C2FC_1CEFC 6 78.432%
func_800226F0_232F0 7 82.472%
func_8005E500_5F100 20 97.917%
func_8005AB58_5B758 10 44.117%
func_8005ECB8_5F8B8 17 88.777%
transformVector 18 82.048%
func_8003A52C_3B12C 13 55.020%
func_800653E0_65FE0 16 93.890%
func_80065150_65D50 22 78.598%
func_80065670_66270 13 67.305%
func_800BB2B0_B2870 30 84.419%
func_80058CFC_598FC 2 57.581%
transformVectorRelative 13 86.695%
func_8005AE8C_5BA8C 12 63.967%
func_800441A4_44DA4 7 84.412%
func_80062CF0_638F0 12 92.6%
func_8005EFC4_5FBC4 16 95.142%
func_8001FFE4_20BE4 5 56.509
func_80061A64_62664 14 29.770%
func_8006D4B8_6E0B8 10 55.937%
func_8000BCEC_C8EC 15 77.509%
func_8007335C_73F5C 1 0%
func_800B3980_A3830 9 69.029%
func_800BC5A8_B3B68 (13 attempts, 94.670%)
func_8001FA00_20600 (7 attempts, 77.851%)
func_800509CC_515CC (15 attempts, 96.545%)
func_800B6618_1E36C8 (24 attempts, 60.949%)
func_80040870_41470 (25 attempts, 98.148%)
func_8002F024_2FC24 (20 attempts, 97.797%)
func_8006BEDC_6CADC 13 86.964%
func_80003D30_4930 27 86.036%
func_8004B3B0_4BFB0 (16 attempts, 90.732%)
func_800B3360 (18 attempts, 99.468%)
func_80032628_33228 (30 attempts, 94.328%)
func_80072960_73560 26 86.2%
func_80004570_5170 17 91.947%
func_80072814_73414 29 90.460%
func_8002FF54_30B54 7 98.714%
func_800625A4_631A4 15 80.079%
func_80064CF4_658F4 27 89.7%
func_8006BFB8_6CBB8 15 96.755%
func_8000DCD8_E8D8 1 0%
func_80059ED0_5AAD0 11 89.879%
initializeGameEntity 2 0%
func_8002AE80_2BA80 6 64.174%
func_8001EB4C_1F74C 1 0%
func_800BB930_B2EF0 4 73.590%
func_800BB2B0_ABAE0 1 0%
func_80062274_62E74 12 3.353%
func_8005DF10_5EB10 7 73.139%
func_800BA694_AA544 13 63.568%
func_8005F344_5FF44 16 86.178%
func_8003F368_3FF68 3 42.152%
func_800B01B8_1DB898 9 73.060%
func_80059394_59F94 (5 attempts, 43.783%)
func_800B844C_1E54FC (7 attempts, 69.497%)
func_80036D54_37954 (3 attempts, 0.000%)
func_80061D6C_6296C (20 attempts, 30.558%)
func_8006B084_6BC84 11 84.505%
func_8005F6DC_602DC 14 93.261%
func_800659E4_665E4 30 73.174%
func_8000E6E0_F2E0 3 0%
func_80049430_4A030 7 54.599%
func_8000FED0_10AD0 14 82.705%
func_80010240_10E40 (4 attempts, 58.883%)
func_800B82D8_A8188 (0 attempts, 0%)
func_800105B0_111B0 2 25.088%
func_80010924_11524 (2 attempts, 48.046%)
func_800600E4_60CE4 (10 attempts, 100%) -- matched in isolation, integration blocked by type incompatibilities
func_80006458_7058 12 67.537%
func_80036424_37024 13 80.689%
func_800B9500_A93B0 30 71.440%
func_80060504_61104 16 95.615%
func_800648EC_654EC 9 66.345%
func_8001A478_1B078 4 83.842%
func_800B7B7C_A7A2C 1 10%
func_80047AA8_486A8 10 33.598
func_800BB75C_ADB1C (4 attempts, 84.134%)
func_800BC378_B0068 (6 attempts, 40.705%)
func_800BB690_AD110 (30 attempts, 30.750%)
func_80045054_45C54 (7 attempts, 56.944%)
func_800B7C48_1E4CF8 (10 attempts, 53.634%)
func_800B6190_1E3240 10 92.328%
func_800B0930 0 0% - Complex state machine with jump table, 1164 bytes
func_8005628C_56E8C 8 68.154%
func_8000EE88_FA88 5 66.139%
func_8005C868_5D468 2 71.015%
func_8005A26C_5AE6C 1 37.286%
func_80012004_12C04 1 36.991%
func_80012518_13118 2 0%
func_80012A58_13658 2 29.612%
matrixToEulerAngles 1 66.611%
func_80039C34_3A834 2 0%
func_80045CC8_468C8 5 24.473%
func_8004674C_4734C 3 0%
func_8003BD60_3C960 4 67.219% -- matched in isolated environment, but fails integration (register allocation mismatch in full build)
func_80035878_36478 3 37.549%
func_80066AF0_676F0 2 24.421%
func_80063A94_64694 1 0%
func_80010C98_11898 3 0%
func_80013EA0_14AA0 9 24.423%
func_8001B3E8_1BFE8 (2 attempts, 43.719%)
func_8002BFEC_2CBEC (5 attempts, 75.082%)
func_800B9EF0_A9DA0 (2 attempts, 23.870%)
func_800175E0_181E0 (2 attempts, 0%)
func_80066474_67074 3 72.710%
func_800B1544_A13F4 1 0%
func_80065DD8_669D8 (1 attempts, 0.243%)
func_800112AC_11EAC 1 44.657%
func_80060CDC_618DC (1 attempts, 0%)
func_800670D4_67CD4 (3 attempts, 30.160%)
func_800B05B8_A0468 (4 attempts, 72.229%)
func_800B8894_A8744 (1 attempts, 0.836%)
func_800677F0_683F0 (1 attempts, 0%) - Extremely large function (1772 bytes), complex display list state management
func_8003C2BC_3CEBC (1 attempts, 0%) - Extremely large function (4772 bytes, 937 assembly lines), complex 64-bit arithmetic, extensive struct access
func_80009548_A148 (1 attempts, 0%) - Large function (2064 bytes) with complex rendering code and RDP display list generation
func_80008514_9114 (1 attempts, 0%) - Very large function (2052 bytes, 546 assembly lines) with complex RDP/RSP display list generation, texture loading state management, and matrix transformations
func_80008D18_9918 (2 attempts, 0%) - Very large function (2096 bytes, 695 assembly lines) with complex RDP display list generation, texture management, graphics mode switching, and matrix transformation setup
func_800136E0_142E0 (6 attempts, 70%)
func_80011924_12524 (3 attempts, 65.605%)
func_80012FA8_13BA8 (1 attempts, 42.128%)
renderTextPalette (3 attempts, 93.497%)
renderTextColored (1 attempt, 0%)
func_80004920_5520 (4 attempts, 12.469%)
func_80005094_5C94 (4 attempts, 49.662%)
func_80038420_39020 (1 attempt, 0%)
func_8001CD90_1D990 (1 attempt, 0%) - Very large save menu state machine (4048 bytes, 25 switch cases, 61-entry jump table)
func_8006E054_6EC54 (1 attempt, 0%) - Extremely large graphics/rendering function (5284 bytes), complex RDP/RSP display list generation, multiple rendering modes, matrix transformations
func_80022D74_23974 (1 attempt, 0%) - Extremely large character selection menu state machine (~64KB, 15 switch cases, complex controller input handling, character/board selection logic)
func_800397CC_3A3CC 14 81.0
func_80058C64_59864 22 91.250%
func_8002F12C_2FD2C 18 90.551%
func_80033E40_34A40 (7 attempts, 100%) -- matched in isolated environment, but fails integration (compiler reordering issues)
func_80024D40_25940 30 99.429%
func_80024DCC_259CC 1 ~85%
func_80044684_45284 15 97.262%
setupSlotTransform 12 93.243%
func_800B2F2C 8 0
func_8002F72C_3032C 30 98.71%
func_80031138_31D38 1 0% -- Non-matching due to compiler differences: GCC_KMC generates beqzl for inner condition (original uses bnez), hoists constant 0x10 to $s3 (original loads inline in delay slot)
func_80003898_4498 10 99.697%
func_8004106C_41C6C 30 95.461% -- Register allocation mismatch: compiler assigns arg0 to s0 but target uses s1
func_800477E4_483E4 1 ~98% -- Register allocation mismatches in loop
func_8004562C_4622C 1 -- Failed decompilation attempt, checksum mismatch
func_8004AFF8_4BBF8 1 -- Failed decompilation attempt, checksum mismatch
func_80028480_29080 1 -- Failed decompilation attempt, checksum mismatch
func_80041418_42018 1 -- Failed decompilation attempt, register allocation mismatch (s2/s3/s4 swapped)
func_80005E54_6A54 1 -- Failed decompilation attempt, checksum mismatch
func_800BB778_AF468 30 95.120% -- Register allocation mismatch: loop counter/offset swap (v1/a0), numPlayers load pattern differs
func_800B4378_1E1428 30 97.829% -- Register allocation mismatch: addu/lhu scheduling (v0/v1 swap), FA loads before F8
func_80045B3C_4673C 30 99.268%
func_800B7620_1E46D0 30 93.850% -- Compiler optimization difference: bltzl/negu abs pattern not generated in first branch, register allocation mismatch (mflo v1 vs mflo v0)
atan2Fixed 13 ~0% -- Compiler optimization: (x<<16)>>15 to x<<1, branch inversion (bnez to beqz+j), affects function size and subsequent symbol addresses
func_800B217C_A202C 24 97.778% -- Delay slot scheduling mismatch: compiler puts move a0,s0 in wrong delay slots (nop/move a0 swapped between two jal calls)
func_800B2254_A2104 9 97.391%
func_800B23DC_A228C 30 90.625% -- Register allocation mismatch: compiler uses v0 for both return value and -1 constant instead of v0/v1 split, stores unkBCD before unkBB5
func_80025074_25C74 30 92.766% -- Instruction scheduling mismatch: compiler reorders addu a1/v0 computation and li a3/v0 sequence, sw delay slot placement differs
func_80055C80_56880 30 83.333% -- Instruction scheduling mismatch: compiler places function address load (lui/addiu) after all register saves, target places it between s2 and s3 saves
func_80054D70_55970 15 98.974% -- Register allocation mismatch: compiler assigns arg0 to s2 instead of s1, loop counter i to s1 instead of s2
func_800BB2B0_B4BB0 30 99.054% -- Register allocation mismatch: compiler assigns state to s3 and dst to s2, target uses s2 for state and s3 for dst
func_80026FF4_27BF4 30 99.184% -- Register allocation mismatch: compiler assigns arg0 to s0 and dmaResult to s1, target uses s1 for arg0 and s0 for dmaResult
func_80026028_26C28 20 88.804% -- Register allocation mismatch: compiler uses a3/a2/a1 for DDBE/DDC2/counter instead of a2/a1/a0, adds intermediate pointer a0=s0+4, lhu instead of lh for DDC2
func_8004E2D8_4EED8 27 97.731
func_800BBCFC_AE0BC 35 98.000% -- Register allocation mismatch: compiler loads unk78 directly into v1 with nop delay slot, target loads into v0 then moves to v1 in delay slot
func_80024810_25410 10 ~0% -- Register allocation mismatch: compiler does not allocate localPtr to s1 register, uses addiu+sp instead of move from saved register, and generates sll s0,s0,0x14 instead of and s0,s0,v0 for adjustment calculation
func_8004FAB4_506B4 29 99.773% -- Sign extension register allocation mismatch: compiler generates sll a1,s0,0x10 then sra a1,a1,0x10 instead of sll s0,s0,0x10 then sra a1,s0,0x10
func_8001F5EC_201EC 30 98.907% -- Register allocation mismatch: compiler assigns count to a2 and ptr to a1 instead of a1/a2
func_80020924_21524 30 92.554% -- Register allocation mismatch: compiler assigns counter to s1 and element pointer to s0+0x40 instead of s0 and s1, optimizes stores to -0x4(s0) and 0(s0) instead of 0x3C(s1) and 0x40(s1)
func_800B0720_1DACC0 20 97.294% -- Register allocation and stack size mismatch: compiler uses 0x20 stack vs 0x28 target, loop registers (a1/a2/a3 vs v0/v1/a2/a3)
func_8004CDC0_4D9C0 30 98.923% -- Stack frame size mismatch: compiler generates 0x28 stack vs 0x30 target, all register offsets shifted by 8 bytes
func_80028C08_29808 5 ~88% -- Register allocation mismatch with goto pattern: compiler hoists unk5E load to a0 instead of v1, reuses value instead of reloading at each use site. Function has shared epilogue via goto where two paths call func_80001688_2288 with different args.
func_8003466C_3526C 19 90%
func_80024990_25590 30 95.211% -- Register allocation and instruction scheduling mismatch: compiler reorders addu a1/v0 sequence (arg1/arg2 address calculation), swaps li a3/v0 order for -1 constants, places sw v0,0(s0) after memcpy jal instead of before
func_800B62E4_A6194 (8 attempts, 89%)
func_8001F7C8_203C8 (30 attempts, 97.1%) -- Register allocation mismatch: compiler assigns s1 for arg0+0x18 instead of s0, instruction scheduling differences for addiu s1,sp,0x80 and addiu s0,s2,0xc, temp variable uses a3 instead of a0
func_800B00C0_1DC260 (22 attempts, 83.5%) -- Register allocation mismatch: compiler allocates temps to a2/a3/t0/t1 instead of a3/t0/t1/t2, constants to v0/a1/v1 instead of v1/a2/a1
func_80044DB0_459B0 30 98.696%
func_80034BD8_357D8 (30 attempts, 96.774%) -- Register allocation mismatch: compiler loads counter into v0 instead of a0, generates negu s3,s3 instead of negu s3,a0, instruction scheduling differences for li s5/move s0/lbu/lui sequence
func_800BB310_ACD90 15 94.800%
func_800BC550_AE910 (27 attempts, 98.670%) -- Register allocation mismatch: compiler assigns arg0 to s2 instead of s3, function pointer to s3 instead of s4, resulting in one fewer saved register used
func_800B6688_A6538 20 98.784%
func_8002ADB4_2B9B4 (30 attempts, 97.255%) -- Register allocation mismatch: compiler assigns sign-extended arg0 to a3 instead of a2, arg1 copy to a2 instead of a3, affecting entire function register usage
func_80027544_28144 (30 attempts, 98.288%) -- Compiler optimization mismatch: compiler elides li v0,2 in else branch because v0 already equals 2 from the bne comparison, target code explicitly reloads v0=2 before setting var_s2=-0x13
func_800BC61C_B1B0C 30 90.202%
func_800BC0E8_AC918 22 82.435%
func_80033254_33E54 (30 attempts, 95.389%) -- Register allocation mismatch: compiler assigns s2 for var_s3 and s3 for var_s2 instead of s3/s2, s4 for var_s5 instead of s5, stack frame 0x38 instead of 0x40
func_80034AC0_356C0 (3 attempts, 100%) -- Matched in isolated environment, but fails integration due to register allocation mismatch: compiler uses different register assignments for loop variables (t0/t1 vs t1/t2), misses sign extension sll+sra sequence in negation path
func_80026564_27164 (18 attempts, 94.243%) -- Register allocation and sign extension mismatch: compiler generates move a3,v0 instead of sll v0,v0,0x10/sra a3,v0,0x10 for u16 to s16 sign extension, stack frame 0x20 instead of 0x38, instruction scheduling differs for move a0,t2 placement
func_800261BC_26DBC (25 attempts, 93.429%) -- Stack frame 0x20 instead of 0x38, instruction scheduling differences: sh v1,8(v0)/sh a0,0(v0) order reversed, li t1/move v1/sll a2/move a0 ordering differs from target
func_80020A00_21600 (41 attempts, 97.000%) -- Constant folding mismatch: compiler computes s2=arg0+0xF0 at initialization instead of keeping s2=arg0 and using 0xF0 offset in loop body. Target uses lhu a1,0xf0(s2)/sh a1,0xf0(s2) with s2 incrementing by 2, our code uses lhu a1,0(s2)/sh a1,0(s2) with s2 starting at arg0+0xF0
func_8005D818_5E418 (30 attempts, 97.093%) -- Register allocation mismatch: compiler uses andi v0,v0,0x7 instead of andi v1,v0,0x7, and uses different register order for array access (lui v1 instead of lui v0 for table address)
func_8004DB98_4E798 (25 attempts, 94.667%) -- Instruction scheduling mismatch: compiler places slti v0,v1,7 after lui/addiu for taskFunc address instead of before, also generates sltiu (unsigned) instead of slti (signed) for u8 field comparison
func_80025EE4_26AE4 (30 attempts, 87.581%) -- Register allocation mismatch: compiler uses 8 saved registers (s0-s7) instead of 7 (s0-s6), assigns s0 for arg0 instead of s2, creates s1=s0+0xA optimization for unkA/unkD field access instead of direct 0xa(s0)/0xd(s0) stores, also swaps loop counter (s2 vs s1) and base pointer (s4 vs s3) registers
func_80054658_55258 (19 attempts, 87.908%)
func_8002CFAC_2DBAC (24 attempts, 80.673%) -- Register allocation mismatch: compiler uses s8 for 0xFFB30000 constant instead of s6, assigns arg0 to s0 instead of s1, ptr to s7 instead of s0, stack frame 0x48 instead of 0x50
func_80025DAC_269AC (30 attempts, 97.756%)
func_800316AC_322AC 30 98.488%
func_80046464_47064 (30 attempts, 97.778%) -- Register allocation mismatch: compiler assigns a0 to loop counter i and v1 to offset, target has v1 for loop counter and a0 for offset, instruction scheduling differences for move v1,zero/lui a1,0xc/move a0,zero order
func_800B5F2C_1E2FDC (30 attempts, 92.121%) -- Instruction scheduling mismatch: compiler does not reload unk20 from memory after store (uses move a3,v0 instead of lh a3,0x20(a0)), also sb zero,0x70(a0) scheduled after slti instead of after andi. With volatile, gets 88.4% but uses lhu+sll+sra instead of lh.
func_800B5FB0_1E3060 (11 attempts, ~75%) -- Instruction scheduling mismatch: compiler reorders andi a1,a1,0x1fff before unk22 load-mask-store-load sequence, sb zero,0x70(a0) also scheduled differently, sh a1,0x26(a0) placed in wrong location
func_800B5590_1E2640 (11 attempts, 99.8%) -- CSE optimization mismatch: compiler caches &D_663BE0 in s1 register and reuses for both dmaRequestAndUpdateStateWithSize calls, target loads address separately each time. Cannot be resolved without linker symbol aliasing which breaks splat regeneration.
func_800B3F64_1E1014 (32 attempts, 98.421%) -- Instruction scheduling mismatch: compiler schedules lbu v0,0x13(v0) before lui v1,0x1 to fill load delay slot, target has lui v1,0x1 first then lbu v0,0x13(v0). All other aspects match perfectly.
func_80009F90_AB90 (30 attempts, 77.949%) -- Register allocation mismatch: compiler generates move a1,a0/move a0,a2 to save state and move arg2 to a0, target generates move a1,a2 to save arg2 while keeping state in a0. This fundamental register allocation difference propagates through the entire function, cannot be resolved with standard C code techniques.
func_8005127C_51E7C (30 attempts, 96.471%) -- Instruction scheduling mismatch: compiler places sw ra/sw s0 before lui for function pointer instead of after li a3, and uses li a3,0xdd in jal delay slot instead of sw s0,0x10(sp). The FAKE_USE macro forces s4 save to correct position but cannot control ra/s0 scheduling.
func_8006BDBC_6C9BC (25 attempts, 91.946%) -- Compiler optimization mismatch: GCC generates addiu t2,t3,4 to precompute array element offset for src[1]/src[2] accesses, target code uses direct lh offsets 0/2/4 from single t2 register. Register allocation: compiler uses t3/t4/t5 vs target t2/t3/t4. Cannot be resolved with standard C code techniques due to GCC array access optimization.
func_8006BE4C_6CA4C (30 attempts, 95.857%) -- Register allocation mismatch: compiler assigns row pointer to t0 and inner counter to t2, target uses t2 for row and t1 for counter. Third dot product term load order swapped (col before row vs row before col). Similar to func_8006BDBC: GCC array optimization cannot be disabled.
func_80073E20_74A20 (22 attempts, 100% in isolation) -- Matched perfectly in isolated environment (base_22.c), but fails integration due to register allocation mismatch: compiler uses a0 directly without move a2,a0 copy at function start when compiled within player.c context. Struct type difference (s16 vs u16 for cont_vol_repeat_count) in full build context affects code generation.
func_80035408_36008 (18 attempts, 87.900%) -- Register allocation mismatch: compiler uses s2 for arg0 instead of s3, missing s6 register allocation for unused variable (li s6,0xfffe in delay slot), shift source register (srl s0,a0,0xc vs srl v0,a2,0xc), branch pattern (beqzl vs bnez/move delay slot), u8 parameter masking (andi v0,s5,0xff before sw vs direct sw s5)
func_80037D18_38918 10 91.489%

func_80027400_28000 (31 attempts, 99.753%) -- Instruction scheduling mismatch: compiler generates 'move s0,s3' before 'move s4,v0' instead of after, stack frame and register allocation otherwise match perfectly

func_8002BCF0_2C8F0 (27 attempts, 97.235%) -- Register allocation mismatch: compiler assigns s0 for arg0 instead of s3, s1 for elem instead of s0, s3 for loop counter i instead of s1. Stack frame size and control flow match perfectly. Also has addu operand ordering difference (addu v1,s4,v1 vs addu v1,v1,s4) and xori/sltiu/and sequence ordering.

func_80041B18_42718 (26 attempts, 93.676%) -- Prologue instruction scheduling mismatch: compiler generates sw s3/lui s3/addiu s3/sw s2/move s2/sw s0/move s0 instead of sw s0/move s0/sw s3/lui s3/addiu s3/sw s2/move s2. Function body from 42758 onwards matches perfectly. Register allocation and control flow are correct, only prologue register save ordering differs.

func_8002529C_25E9C (21 attempts, 90.902%) -- Register allocation and pointer addressing mismatch: compiler generates v1=s0+0x10 and uses negative offsets (-0xe, -8, -6, -4, -0xc, -2) instead of target's v1=s0 with positive offsets (2, 8, 0xa, 0xc, 4, 0xe). Also register assignments differ: initialY to a1 vs t1, var_t0 to t1 vs t0, var_a3 to t0 vs a3, loop counter to a3 vs a2. Matched 100% when using INCLUDE_ASM but C decompilation fails integration.

func_800218AC_224AC (11 attempts, 89.642%) -- Same pointer addressing issue as func_8002529C_25E9C: loop uses two pointer registers (a0 with base+0xC and negative offsets, a3 with base) instead of single register a0 with positive offsets 0,2,4,8,A,C,D. Also loop variable setup happens after division computation instead of before. Target: move a1,zero / li t0,0x1c / li a3,0xff / move a0,s1 / li a2,-0x28 before sll/sra, but compiler puts these after addiu v1,v1,-0x90.

func_80022130_22D30 (9 attempts, 90.009%) -- CSE optimization mismatch: compiler caches func_800B00C0_9FF70, D_800B09A0, D_800B09F0 and reuses with move instruction instead of separate lui/addiu loads for each parameter. Target loads each address separately. Cannot be resolved without linker symbol aliasing which breaks splat regeneration. Similar to func_800B5590_1E2640.

func_8004CA90_4D690 (23 attempts, 81.114%) -- Instruction scheduling mismatch: compiler does not interleave address setup for second dmaRequestAndUpdateStateWithSize call with x/y struct field loads. Target interleaves lui/addiu for D_3F6670/D_3F6950 with lhu for unk4/unk6/unk14/unk16, compiler places address setup after the struct stores/loads. Also uses immediate values for x/y instead of reading back from struct fields.

func_8004A6D4_4B2D4 (30 attempts, 95.453%) -- Register allocation mismatch: compiler assigns arg0 to s1 instead of s2, resulting in s1/s2 swap for arg0/allocation throughout entire function. Loop variable correctly uses s0 with i=(s32)s0 pattern. Control flow, struct accesses, and instruction scheduling all match perfectly.

func_800073E0_7FE0 (31 attempts, 98.989%) -- Register allocation mismatch: compiler uses a1 for constant 1 instead of a0, v1 for var_v0 instead of v0, a0 for temp_v1 instead of v1. Fixed sp10.unk14/18/1C writes (originally misidentified as dead stores sp24/sp28/sp2C). Control flow with goto labels matches perfectly. Symbol addresses equivalent (D_8009A890_9B490+0x14 == D_8009A8A4_9B4A4).

func_800B8AC4_1E5B74 (17 attempts, 99.681%) -- Register allocation mismatch: compiler generates srl v0,a1,0x1f / slt v1,zero,a0 / and v1,v1,v0 / bnez v1 instead of target's srl v1,a1,0x1f / slt v0,zero,a0 / and v0,v0,v1 / bnez v0 for the (temp_a0 > 0 && temp_a1 < 0) sign check condition. All other logic matches perfectly. Added unk94, unk98, unk9C_u union (unk9C s32 / unk9C_parts.unk9E s16) to CutsceneSlotData struct at offsets 0x94-0x9F.

func_80054AE4_556E4 (2 attempts, 75.896%) -- Stack frame size mismatch: compiler generates 0x38 stack instead of 0x80 target, register allocation mismatch (s0/s1/s2 vs s0/s1/s2/s3), compiler saves 3 registers instead of 4. Function requires specific struct type with unk30/unk34/unk38 fields at offsets 0x30-0x3B to access velocity-related values. Local struct typedef works in isolated sandbox but fails integration due to IDO compiler's register allocation being context-sensitive.

func_80035548_36148 (30 attempts, 90.517%) -- Stack frame 0x40 instead of 0x48 (missing s7 for unused variable), register allocation mismatch (s2/s4 swap for x/i variables), instruction pattern mismatch for sz=cmd>>12 (srl s0,a0,0xc + beqzl vs srl v0,a2,0xc + bnez + move s0,v0). Similar to func_80035408_36008 but with additional unk11 iteration limit check. Best version: base_29.c with i=0 after unused=0xFFFE, uses s32 for function parameter 6.

func_8004F27C_4FE7C (8 attempts, 100% isolation) -- Matched 100% in isolated environment but fails integration. Register allocation mismatch: compiler uses a2 for bonus variable instead of t1, compiler uses v1/a0 for strlen loop instead of t1/v1. Control flow with goto for unk7A==4 || (unk7A==6 && unkB70>=300) -> bonus=5000 pattern matches in isolation. Similar to func_8003BD60_3C960 (also matched in isolation but fails integration). Full build context changes register allocation decisions.

func_80026BD8_277D8 (12 attempts, 95.494%) -- Stack frame size mismatch: compiler generates 0x20 stack vs 0x30 target. Register allocation mismatch: compiler creates two pointers (addiu v1,s0,4 + move a3,s0) for entry iteration instead of single pointer (move v1,s0). Loop variable stored to a3 and incremented separately vs unified v1 pointer. Also t0/t1 swapped for lookup table registers.

func_80015A18_16618 (9 attempts, 97.454%) -- CSE optimization mismatch: compiler caches &D_418520 in s0 register and reuses for both dmaRequestAndUpdateStateWithSize calls, target loads address separately each time. Cannot be resolved without linker symbol aliasing which breaks splat regeneration. Similar to func_800B5590_1E2640.

func_800B0A54_1DAFF4 (17 attempts, 80.969%) -- Register allocation and pointer precomputation mismatch: compiler precomputes allocation+0x5C1 into s2 register and uses negative offset -0x27 for unk59A access (0x5C1-0x27=0x59A), target keeps allocation base in s2 and uses large positive offsets 0x59A and 0x5C1. Also compiler precomputes arg0+0x40 and arg0+0xA into s1/s0 registers instead of keeping single pointer with 0x40/0xA offsets. This is a fundamental GCC vs IDO optimization difference that cannot be resolved with standard C code techniques.

func_800B9440_1E64F0 (30 attempts, 90.733%) -- Delay slot scheduling and branch type mismatch: compiler generates 'sh v0,0x20(s0) / beqzl v1,54' instead of target's 'bnez v1,54 / sh v0,0x20(s0)' (store in delay slot). The bnez branch pattern with delay slot store cannot be generated by GCC_KMC compiler which always uses beqzl likely branch. Also register save order differs (sw s4/s2 vs sw s2/s4). Best version: base_21.c with volatile for correct register allocation (move s0,s1) but wrong branch type.

func_800BC89C_B1D8C (22 attempts, 91.259%) -- Register allocation and array relocation mismatch: compiler assigns s0 for arg0 instead of s1, s1 for counter i instead of s2, s2 for offset array index instead of s3, s3 for entry ptr instead of s4, s4 for unused instead of target's s4=entry ptr, s5 for allocPlus30, s6 for flag. Array access generates +8 LO16 relocation for column 2 access instead of using row/column offset pattern. Loop comparison uses slti v0,s1,9 (counter-based) correctly but stores to different base registers (sw v0,0(s3) vs sw v0,0xa10(s4)). Similar to func_800BC330_ACB60 in crazy_jungle_boss which matches, but conditional flag check adds complexity.
func_80036AF8_376F8 (30 attempts, 93.595%) -- Register allocation mismatch: compiler generates move v0,t1 for masked assignment instead of using andi directly from t1, loads t6=0xfffd instead of t7=0xfffd for first constant, srl v1,t1,0xc instead of srl v0,t1,0xc for charWidth, loop-back branch bne t1,t4,30 with move v0,t1 in delay slot instead of bne t1,t4,34 with andi a3,t1,0xffff
func_8005D308_5DF08 (15 attempts, 90.121%) -- Register allocation mismatch: compiler assigns arg0 to s0 but target uses s1, loop counter to s1 instead of s0, offset to s2 (correct). Stack frame 0x28 instead of 0x40. Cannot be resolved with standard C code techniques.

func_800478FC_484FC (23 attempts, 92.022%) -- Register allocation mismatch: compiler assigns arg0 to s0 instead of s1, uses 7 saved registers (s0-s6) instead of 6 (s0-s5), stores constant 2 in s4 instead of using li v1,2 inline. Stack frame 0x38 instead of 0x40. Control flow matches perfectly with bnezl for main branch. Cannot be resolved with standard C code techniques.

func_80026860_27460 (5 attempts, ~97%) -- Matched 100% in isolated environment (diff shows 0 differences), but fails integration with major differences in compiled output. Stack frame size mismatch (target 0x30 vs compiler 0x20-0x28), register allocation mismatch (compiler assigns loop variables and struct pointers to different registers), instruction scheduling differs throughout. Uses D_8008DE54_8EA54/D_8008DE9C_8EA9C as 4-byte indexed arrays with struct field access at offsets 0/2 for u16 values. Similar to func_80026BD8_277D8 (also 4-byte array pattern). Cannot be resolved with standard C code techniques.

func_8004C2C0_4CEC0 (4 attempts, ~0%) -- Requires undefined linker symbol _3F6420_ROM_START (intermediate ROM address 0x3F6420 within _3F58E0 asset). Cannot add symbol to linker script as it's auto-generated from YAML. Splitting asset in YAML shifts all ROM addresses by 0x10. Register allocation mismatch: compiler uses s0/s1/s2 (arg0/allocation/extra) instead of target s0/s1 (arg0/allocation). Cannot be resolved without linker symbol aliasing or YAML modification which breaks global ROM layout.

func_80016488_17088 (30 attempts, 82.729%) -- Stack frame size mismatch: compiler generates 0x20 stack vs 0x28 target. Register allocation mismatch: first loop uses a2/a3/a1 for entry/counter/yPos instead of v1/a0/a1, second loop uses v1 for entry pointer with negative offsets instead of v0 with positive offsets. The extra 8 bytes in target stack frame suggests different local variable allocation or alignment requirements that GCC_KMC does not reproduce.

func_8005D48C_5E08C (21 attempts, 65.107%) -- Register allocation mismatch: compiler assigns arg0 to s0 instead of s1, loop counter i to s2 instead of s0, offset to s1 instead of s2. Stack frame size matches at 0x48 but register save order differs. Loop structure uses blez/beqz mismatch and sign extension patterns differ. Cannot be resolved with standard C code techniques.

func_8005D180_5DD80 (21 attempts, 88.820%) -- Register allocation mismatch: compiler assigns arg0 to s0 instead of s1, loop counter to s1 instead of s0. Stack frame size mismatch: compiler generates 0x28 instead of 0x40 target. Logic is correct but register/stack differences cannot be resolved with standard C code techniques. Very similar pattern to func_8005D308_5DF08 which shares identical prologue.

func_8001960C_1A20C (20 attempts, 85.162%) -- Register allocation and pointer arithmetic mismatch: compiler generates addiu v1,v1,2 (modifies base register) instead of addiu v0,s2,2 (computes base+2 into new register) for ptrY calculation. Stack frame 0x30 instead of 0x38 (6 saved regs instead of 8). Target keeps idx in s1 and base in s2, computes ptrX=idx+base into s7, temp=base+2 into v0, then ptrY=idx+temp into s6. Compiler folds idx+2+base into single expression. Cannot be resolved with standard C code techniques.

func_800B3FFC_1E10AC (24 attempts, 92.1%) -- Register allocation mismatch: compiler assigns var_s6 to s4 instead of s6, var_s5 to s6 instead of s5, resulting in register swap throughout function. Delay slot scheduling differs: target puts addiu s0,s0,4 in jal delay slot for position calculation, compiler does not schedule +4 into delay slot. Inner loop pointer assignment uses move a0,v0/lhu v0,0x3c(a0)/move s1,a0 instead of target's move s1,v0/lhu s0,0x3c(v0).

func_80033F7C_34B7C (17 attempts, 93.907%) -- Sign extension mismatch: compiler generates sll v0,s7,0x10 / sra v0,v0,0x10 / addu v0,s4,v0 for s16 var_s7 pointer offset instead of target's direct addu v0,s4,s7. Target uses register s7 holding -0x90 (sign-extended 32-bit) without explicit sign extension. Also jump delay slot scheduling differs: target puts sh a3,0x66(s1) in delay slot, compiler schedules addiu s8,s8,0x10 instead. Register allocation mismatch s2/s3 for loop counter and unk2_val.

func_8002E680_2F280 (15 attempts, 77.845%) -- Register allocation mismatch: compiler assigns ptr element tracking to s4 with additional s0=s3+0x5C offset register for unk5A/5C/5E field accesses instead of target's single s0 register starting at arg0 and incrementing by 0x64. Compiler splits struct access into separate address ranges (s0 tracks 0x5C region, s6 tracks unk4 matrix at offset 4). Target uses unified base pointer with explicit offsets 0x50(s0), 0x18(s0), 0x5C(s0) etc. This is a fundamental GCC struct field optimization that cannot be disabled. Also s4/s8 swap for loop counter i, s6/s7 swap for sp30/offsetIdx.

func_800BB320_B5C00 (30 attempts, 98.937%) -- Register allocation mismatch: compiler assigns getCurrentAllocation result to a1 instead of v1, switch value to v1 instead of a0. Throughout function: target uses v1 for alloc pointer and a0 for player pointer in cases that load players, compiler uses a1 for alloc and v1 for player. Switch statement structure, control flow, and all other aspects match perfectly. This register allocation difference is a fundamental GCC_KMC vs IDO optimization difference that cannot be resolved with standard C code techniques.
